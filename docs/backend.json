{
  "entities": {
    "SparePart": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SparePart",
      "type": "object",
      "description": "Represents a spare part available in the marketplace.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the spare part."
        },
        "name": {
          "type": "string",
          "description": "Name of the spare part."
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the spare part."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the image representing the spare part.",
          "format": "uri"
        },
        "manufacturer": {
          "type": "string",
          "description": "Manufacturer of the spare part."
        },
        "modelNumber": {
          "type": "string",
          "description": "Model number of the spare part."
        },
        "unitPrice": {
          "type": "number",
          "description": "Unit price of the spare part."
        },
        "quantityAvailable": {
          "type": "number",
          "description": "Quantity of the spare part currently available."
        },
        "supplierIds": {
          "type": "array",
          "description": "References to Suppliers. (Relationship: Supplier N:N SparePart)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "manufacturer",
        "modelNumber",
        "unitPrice",
        "quantityAvailable"
      ]
    },
    "Supplier": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Supplier",
      "type": "object",
      "description": "Represents a supplier of spare parts.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the supplier."
        },
        "name": {
          "type": "string",
          "description": "Name of the supplier."
        },
        "contactEmail": {
          "type": "string",
          "description": "Contact email address of the supplier.",
          "format": "email"
        },
        "location": {
          "type": "string",
          "description": "Location of the supplier."
        },
        "rating": {
          "type": "number",
          "description": "Rating of the supplier (e.g., based on customer reviews)."
        },
        "sparePartIds": {
          "type": "array",
          "description": "References to SpareParts. (Relationship: Supplier N:N SparePart)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "name",
        "contactEmail",
        "location",
        "rating"
      ]
    },
    "EquipmentFailurePrediction": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EquipmentFailurePrediction",
      "type": "object",
      "description": "Represents a prediction of equipment failure, generated by the AI system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the equipment failure prediction."
        },
        "equipmentId": {
          "type": "string",
          "description": "Identifier of the equipment predicted to fail."
        },
        "predictedFailureTime": {
          "type": "string",
          "description": "Timestamp indicating the predicted time of failure.",
          "format": "date-time"
        },
        "confidenceLevel": {
          "type": "number",
          "description": "Confidence level of the prediction (e.g., percentage)."
        },
        "sparePartId": {
          "type": "string",
          "description": "Reference to SparePart. (Relationship: EquipmentFailurePrediction 1:N SparePart)"
        }
      },
      "required": [
        "id",
        "equipmentId",
        "predictedFailureTime",
        "confidenceLevel",
        "sparePartId"
      ]
    },
    "Order": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "type": "object",
      "description": "Represents an order placed for spare parts.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the order."
        },
        "orderDate": {
          "type": "string",
          "description": "Date when the order was placed.",
          "format": "date-time"
        },
        "totalAmount": {
          "type": "number",
          "description": "Total amount of the order."
        },
        "status": {
          "type": "string",
          "description": "Status of the order (e.g., pending, processed, shipped, delivered)."
        },
        "supplierId": {
          "type": "string",
          "description": "Reference to Supplier. (Relationship: Order 1:N Supplier)"
        },
        "sparePartIds": {
          "type": "array",
          "description": "References to SpareParts. (Relationship: Order N:N SparePart)",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "orderDate",
        "totalAmount",
        "status",
        "supplierId"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/spare_parts/{sparePartId}",
        "definition": {
          "entityName": "SparePart",
          "schema": {
            "$ref": "#/backend/entities/SparePart"
          },
          "description": "Collection of spare parts available in the marketplace.",
          "params": [
            {
              "name": "sparePartId",
              "description": "Unique identifier for the spare part."
            }
          ]
        }
      },
      {
        "path": "/suppliers/{supplierId}",
        "definition": {
          "entityName": "Supplier",
          "schema": {
            "$ref": "#/backend/entities/Supplier"
          },
          "description": "Collection of suppliers providing spare parts.",
          "params": [
            {
              "name": "supplierId",
              "description": "Unique identifier for the supplier."
            }
          ]
        }
      },
      {
        "path": "/equipment_failure_predictions/{equipmentFailurePredictionId}",
        "definition": {
          "entityName": "EquipmentFailurePrediction",
          "schema": {
            "$ref": "#/backend/entities/EquipmentFailurePrediction"
          },
          "description": "Collection of equipment failure predictions generated by the AI system.",
          "params": [
            {
              "name": "equipmentFailurePredictionId",
              "description": "Unique identifier for the equipment failure prediction."
            }
          ]
        }
      },
      {
        "path": "/orders/{orderId}",
        "definition": {
          "entityName": "Order",
          "schema": {
            "$ref": "#/backend/entities/Order"
          },
          "description": "Collection of orders placed for spare parts.",
          "params": [
            {
              "name": "orderId",
              "description": "Unique identifier for the order."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support the Green Box Marketplace platform, emphasizing authorization independence, clarity, and scalability. It leverages structural segregation and denormalization strategies to ensure secure and efficient data access.  The key principle is to avoid `get()` calls in security rules by denormalizing authorization data, which enables atomic operations and simplifies debugging.  This architecture facilitates listing (QAPs) and write operations across the collections.\n\nAuthorization Independence is achieved primarily through denormalization. For example, while the relationship between `SparePart` and `Supplier` is N:N, `SparePart` includes `supplierIds` array. This denormalization avoids the need for security rules to traverse the database to check relationships during write operations.\n\nStructural Segregation is implemented by separating the entities into different top-level collections, each serving a distinct purpose: `spare_parts`, `suppliers`, `equipment_failure_predictions`, and `orders`. This separation ensures a homogeneous security posture for each collection.\n\nAccess Modeling relies on collection-based access for SpareParts, Suppliers and EquipmentFailurePredictions and Orders."
  }
}